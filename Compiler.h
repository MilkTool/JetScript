#pragma once

class BlockExpression;
#include <string>
#include <map>
#include "Token.h"

class CompilerContext
{

public:
	std::string output;

	std::map<std::string, CompilerContext*> functions;

	CompilerContext* AddFunction(std::string name)
	{
		//push instruction that sets the function
		//todo, may need to have functions in other instruction code sets
		
		CompilerContext* newfun = new CompilerContext();
		//insert this into my list of functions
		newfun->uuid = this->uuid;
		this->functions[name] = newfun;

		this->LoadFunction(name);
		this->Store(name);

		return newfun;
	};

	void FinalizeFunction(CompilerContext* c)
	{
		this->uuid += c->uuid + 1;
	}

	CompilerContext(void);
	~CompilerContext(void);

	std::string Compile(BlockExpression* expr);

private:
	void Compile()
	{
		//append functions to end here
		for (auto fun: this->functions)
		{
			this->output += "\n\n";

			fun.second->Compile();

			//need to set var with the function name and location
			this->FunctionLabel(fun.first);
			this->output += fun.second->output;

			//add code of functions recursively
		}
	}

public:

	void BinaryOperation(TokenType operation);

	void UnaryOperation(TokenType operation);

	void Pop()
	{
		output += "Pop;\n";
	}

	void Duplicate()
	{
		output += "Dup;\n";
	}

	void Number(double value)
	{
		char t[50];
		sprintf(t, "LdNum %lf;\n", value);
		this->output += t;
	}

	void String(std::string string)
	{
		this->output += "LdStr '"+string+"';\n";
	}

	void JumpFalse(const char* pos)
	{
		char t[50];
		sprintf(t, "JmpFalse %s;\n", pos);
		this->output += t;
	}

	void JumpTrue(const char* pos)
	{
		char t[50];
		sprintf(t, "JmpTrue %s;\n", pos);
		this->output += t;
	}

	void Jump(const char* pos)
	{
		char t[50];
		sprintf(t, "Jmp %s;\n", pos);
		this->output += t;
	}

	void FunctionLabel(std::string name)
	{
		this->output += "func " + name + ":\n";
	}

	void Label(std::string name)
	{
		this->output += name + ":\n";
	}

	void Store(std::string variable)
	{
		this->output += "Store " + variable + ";\n";
	}

	void StoreLocal(std::string variable)
	{
		this->output += "Store " + variable + ";\n";
	}

	//this loads locals and globals atm
	void Load(std::string variable)
	{
		this->output += "Load " + variable + ";\n";
	}


	void LoadFunction(std::string name)
	{
		this->output += "LdFn " + name + ";\n";
	}

	void Call(std::string function, unsigned int args)
	{
		this->output += "Call " + function + " " + std::to_string(args) + ";\n";
	}

	void Return()
	{
		this->output += "Return;\n";
	}

private:
	int uuid;

public:
	std::string GetUUID()//use for autogenerated labels
	{
		return std::to_string(uuid++);
	}
};

